// 经典动态规划——背包问题
// 给你两个长度为N的数组W[i],V[i]，W[i]代表第i个货物的重量，V[i]代表第i个货物的价值
// 现在给你一个背包最大的重量weight，问你在不超过背包所能承受的最大重量之内，你能装下货物的最大价值是多少?
#include <iostream>
using namespace std;
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
int process01(int w[], int v[], int index, int bag, int length);

// 写出尝试
// w数组——重量，v数组——价值，bag——背包容量,length——数组长度
// 返回：不超重的情况下能够得到的最大价值
int maxValue01(int w[], int v[], int bag, int length)
{
    // length==0代表没有货物
    if (length == 0)
        return 0;
    // 常式函数
    return process01(w, v, 0, bag, length);
}

// 当前考虑到了第index货物，index之后所有的货物可以自由选择
// 做的选择不超过当前的背包容量
// 返回最大价值
int process01(int w[], int v[], int index, int restbag, int length)
{
    // 如果背包容量＜0了
    if (restbag < 0)
        return -1;
    // 如果下标越界了
    if (index == length)
        return 0;
    // index没到最后并且背包还有空间(哪怕是0也属于有空间)
    // 两种选择，第一个是我不要当前的货，第二个是我要
    int p1 = process01(w, v, index + 1, restbag, length);
    int p2 = 0;
    // 判断第一个物品是否是无效货物
    if (process01(w, v, index + 1, restbag - w[index], length) != -1)
    {
        p2 = v[index] + process01(w, v, index + 1, restbag - w[index], length);
    }
    return max(p1, p2);
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 直接动态规划
int maxValue02(int w[], int v[], int bag, int length)
{
    // 行代表index 0~length
    // 列代表bag 负数~bag
    int dp[100][100];
    for (int i = 0; i <= bag; i++)
        dp[length][i] = 0; // 将最后一行全部设置为0
    for (int index = length - 1; index >= 0; index--)
    {
        for (int rest = 0; rest <= bag; rest++)
        {
            int p1 = dp[index + 1][rest];
            // 如果rest-w[index]<0成立，说明是无效解
            int p2 = rest - w[index] < 0 ? -1 : (dp[index + 1][rest - w[index]] + v[index]);
            dp[index][rest] = max(p1, p2);
        }
    }

    // 返回我需要的dp值
    return dp[0][bag];
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int main()
{
    int weights[4] = {3, 2, 4, 7};
    int values[4] = {5, 6, 3, 19};
    int bag = 11;
    cout << maxValue01(weights, values, bag, 4) << endl;
    cout << maxValue02(weights, values, bag, 4) << endl;
    return 0;
}