// 给定一个字符串str，返回这个字符串的最长回文子序列长度
// eg: str="a12b3c43def2ghi1kpm"
// 最长回文子序列是"1234321"或者"123c321",返回长度7
#include <iostream>
#include <cstring>
using namespace std;
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int process01(char str[], char restr[], int i, int j);
// 尝试一号
int TheLongestPalindromicSubsequence01(char str[], int length)
{
    if (length == 0)
        return 0;
    char *restr = new char[length + 1];
    for (int i = 0; i < length; i++)
    {
        restr[i] = str[length - 1 - i];
    }
    restr[length] = '\0';
    return process01(str, restr, length - 1, length - 1);
}

int process01(char str[], char restr[], int i, int j)
{
    if (i == 0 && j == 0)
    {
        return str[i] == restr[j] ? 1 : 0;
    }
    else if (i == 0)
    {
        if (str[i] == restr[j])
        {
            return 1;
        }
        else
        {
            return process01(str, restr, i, j - 1);
        }
    }
    else if (j == 0)
    {
        if (str[i] == restr[j])
        {
            return 1;
        }
        else
        {
            return process01(str, restr, i - 1, j);
        }
    }
    else
    {
        int p1 = process01(str, restr, i - 1, j);
        int p2 = process01(str, restr, i, j - 1);
        int p3 = str[i] == restr[j] ? (1 + process01(str, restr, i - 1, j - 1)) : 0;
        return max(p3, max(p1, p2));
    }
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 动态规划
int TheLongestPalindromicSubsequence02(char str[], int length)
{
    if (length == 0)
        return 0;
    char *restr = new char[length + 1];
    for (int i = 0; i < length; i++)
    {
        restr[i] = str[length - 1 - i];
    }
    restr[length] = '\0';
    // dp数组
    int dp[100][100];

    dp[0][0] = str[0] == restr[0] ? 1 : 0;
    for (int i = 1; i < length; i++)
    {
        dp[i][0] = str[i] == restr[0] ? 1 : dp[i - 1][0];
    }
    for (int j = 1; j < length; j++)
    {
        dp[0][j] = str[0] == restr[j] ? 1 : dp[0][j - 1];
    }
    for (int i = 1; i < length; i++)
    {
        for (int j = 1; j < length; j++)
        {
            dp[i][j] = max((str[i] == restr[j] ? (1 + dp[i - 1][j - 1]) : 0), max(dp[i][j - 1], dp[i - 1][j]));
        }
    }
    return dp[length - 1][length - 1];
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int process02(char str[], int l, int r);

// 另外一种思路去解决最长回文子序列的问题
int lpsl01(char str[], int length)
{
    if (length == 0)
    {
        return 0;
    }
    return process02(str, 0, length - 1);
}

// 这个递归的含义是——我只看str[l...r]范围内的最长回文子序列的长度返回
int process02(char str[], int l, int r)
{
    if (l == r)
    {
        return 1;
    }
    if (l == r - 1)
    {
        return str[l] == str[r] ? 2 : 1;
    }
    // 既不以l开头也不以r结尾
    int p1 = process02(str, l + 1, r - 1);
    // 不以l开头但是以r结尾
    int p2 = process02(str, l + 1, r);
    // 以r结尾不以l开头
    int p3 = process02(str, l, r - 1);
    // l开头,r结尾
    int p4 = str[l] == str[r] ? 2 + process02(str, l + 1, r - 1) : 0;
    return max(p1, max(p2, max(p3, p4)));
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 动态规划
int lpsl02(char str[], int length)
{
    if (length == 0)
    {
        return 0;
    }
    if (length == 1)
    {
        return 1;
    }
    int dp[100][100];
    for (int i = 0; i < length; i++)
    {
        dp[i][i] = 1;
    }
    for (int i = 0; i < length - 1; i++)
    {
        dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
    }
    for (int i = length - 3; i >= 0; i--)
    {
        for (int j = i + 2; j < length; j++)
        {
            // 既不以l开头也不以r结尾
            int p1 = dp[i + 1][j - 1]; // 可能性p1可以不需要，这里可以进一步优化
            // 不以l开头但是以r结尾
            int p2 = dp[i + 1][j];
            // 以r结尾不以l开头
            int p3 = dp[i][j - 1];
            // l开头,r结尾
            int p4 = str[i] == str[j] ? 2 + dp[i + 1][j - 1] : 0;
            dp[i][j] = max(p1, max(p2, max(p3, p4)));
        }
    }

    return dp[0][length - 1];
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 去除可能性p1以后动态规划的代码可以再一次优化
int lpsl03(char str[], int length)
{
    if (length == 0)
    {
        return 0;
    }
    if (length == 1)
    {
        return 1;
    }
    int dp[100][100];
    for (int i = 0; i < length; i++)
    {
        dp[i][i] = 1;
    }
    for (int i = 0; i < length - 1; i++)
    {
        dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
    }
    for (int i = length - 3; i >= 0; i--)
    {
        for (int j = i + 2; j < length; j++)
        {
            dp[i][j] = max(dp[i][j + 1], dp[i - 1][j]);
            if (str[i] == str[j])
            { // 如果存在可能性4——即这个回文子序列l开头r结尾
                dp[i][j] = max(dp[i][j], 2 + dp[i + 1][j - 1]);
            }
        }
    }
    return dp[0][length - 1];
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int main()
{
    char str[] = "a12b3c43def2ghi1kpm";
    int length = strlen(str);
    // cout << TheLongestPalindromicSubsequence01(str, length) << endl; // 这个代码超时了，所以注释掉
    cout << TheLongestPalindromicSubsequence02(str, length) << endl;
    cout << lpsl01(str, length) << endl;
    cout << lpsl02(str, length) << endl;
    cout << lpsl03(str, length) << endl;
    return 0;
}