// 给定一个整型数组arr，代表数值不同的纸牌排成一条线。
// 玩家A和玩家B依次拿走每张纸牌
// 规定玩家A先拿，玩家B后拿
// 但是每个玩家每次只能拿走最左边或者最右边的纸牌
// 玩家A和玩家B都是绝顶聪明(以最佳的方式做决策)
// 请返回最后获胜者的分数
#include <iostream>
using namespace std;

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int first01(int arr[], int L, int R);
int second01(int arr[], int L, int R);

// 初始代码——尝试
// 根据题意，返回获胜者分数
int win1(int arr[], int length)
{
    if (length == 0)
        return 0;
    int f = first01(arr, 0, length - 1);
    int s = second01(arr, 0, length - 1);
    return max(f, s);
}

// 玩家A先手——先手函数
int first01(int arr[], int L, int R)
{
    // 如果只剩下一张牌了，那就选这个
    if (L == R)
        return arr[L];
    // 如果不是，那就分情况讨论
    // 先手拿走的是左边的牌
    int p1 = arr[L] + second01(arr, L + 1, R); // late是玩家B后手——后手函数
    // 先手拿走的是右边的牌
    int p2 = arr[R] + second01(arr, L, R - 1);
    // 返回的是获得分数最大的那一个
    return max(p1, p2);
}
// 玩家B后手——后手函数
int second01(int arr[], int L, int R)
{
    // 因为是后手，当L==R的时候这张牌已经被先手拿走了，后手的选手获得不了任何东西，返回0
    if (L == R)
        return 0;
    int p1 = first01(arr, L + 1, R); // 代表对手拿了L位置的数，这个时候我需要在拿走之后的数组中找一个最大的数
    int p2 = first01(arr, L, R - 1); // 同上理
    return min(p1, p2);              // 对手拿走位置上的数之后留给我的一定是较小的那一个
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int first02(int arr[], int L, int R, int fdp[100][100], int sdp[100][100]);
int second02(int arr[], int L, int R, int fdp[100][100], int sdp[100][100]);

// 第一次优化——记忆化搜索
int win2(int arr[], int length)
{                      // 二维数组表格的范围应该是[0~L-1]和[0~R-1]
    int fdp[100][100]; // 先手的数组
    int sdp[100][100]; // 后手的数组
    for (int i = 0; i < length; i++)
    {
        for (int j = 0; j < length; j++)
        {
            fdp[i][j] = -1;
            sdp[i][j] = -1;
        }
    }
    int p1 = first02(arr, 0, length - 1, fdp, sdp);
    int p2 = second02(arr, 0, length - 1, fdp, sdp);
    return max(p1, p2);
}

int first02(int arr[], int L, int R, int fdp[100][100], int sdp[100][100])
{
    if (fdp[L][R] != -1)
        return fdp[L][R];
    int res = 0;
    if (L == R)
    {
        res = arr[L];
    }
    else
    {
        int p1 = second02(arr, L + 1, R, fdp, sdp) + arr[L];
        int p2 = second02(arr, L, R - 1, fdp, sdp) + arr[R];
        res = max(p1, p2);
    }
    fdp[L][R] = res;
    return res;
}

int second02(int arr[], int L, int R, int fdp[100][100], int sdp[100][100])
{
    if (sdp[L][R] != -1)
        return sdp[L][R];
    int res = 0;
    if (L != R)
    {
        int p1 = first02(arr, L + 1, R, fdp, sdp);
        int p2 = first02(arr, L, R - 1, fdp, sdp);
        res = min(p1, p2);
    }
    sdp[L][R] = res;
    return res;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 动态规划最终版本
int win3(int arr[], int length)
{
    if (length == 0)
        return 0;
    int fdp[100][100], sdp[100][100];
    for (int i = 0; i < length; i++)
    {
        fdp[i][i] = arr[i];
        sdp[i][i] = 0;
    }
    // 开始根据dp矩阵的对角线向上爬
    for (int startCol = 1; startCol < length; startCol++)
    {
        int row = 0;        // 行
        int col = startCol; // 列
        while (col < length)
        {
            fdp[row][col] = max(arr[row] + sdp[row + 1][col], arr[col] + sdp[row][col - 1]);
            sdp[row][col] = min(fdp[row + 1][col], fdp[row][col - 1]);
            // 对角线往上攀爬
            row++;
            col++;
        }
    }
    return max(fdp[0][length - 1], sdp[0][length - 1]);
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int main()
{
    int arr[13] = {5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 6, 1, 7};
    cout << win1(arr, 13) << endl;
    cout << win2(arr, 13) << endl;
    cout << win3(arr, 13) << endl;
    return 0;
}