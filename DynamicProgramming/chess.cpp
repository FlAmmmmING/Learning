// 象棋问题
// 请同学们自行搜索或者想象一个象棋的棋盘
// 然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
// 那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
// 给你三个参数：x,y,k
// 返回“马”从(0,0)位置出发，必须走k步
// 最后落在(x,y)上的方法数有多少种？
#include <iostream>
using namespace std;
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int process01(int x, int y, int rest, int a, int b);

// 暴力递归实现代码——尝试
// 主函数
int chess01(int a, int b, int k)
{
    return process01(0, 0, k, a, b);
}

//(x,y)我当前在什么地方
//(a,b)我要去的地方
// rest我还剩下几步
// 返回方法数
// 棋盘大小 10 * 9
int process01(int x, int y, int rest, int a, int b)
{
    // 递归终止条件
    // 越界条件
    if (x < 0 || x > 9 || y < 0 || y > 8)
    {
        return 0;
    }
    // 获取方法条件
    if (rest == 0)
    {
        return x == a && y == b ? 1 : 0;
    }

    // 马一共有八种跳法
    int p1 = process01(x + 1, y + 2, rest - 1, a, b);
    int p2 = process01(x + 2, y + 1, rest - 1, a, b);
    int p3 = process01(x + 2, y - 1, rest - 1, a, b);
    int p4 = process01(x + 1, y - 2, rest - 1, a, b);
    int p5 = process01(x - 1, y - 2, rest - 1, a, b);
    int p6 = process01(x - 2, y - 1, rest - 1, a, b);
    int p7 = process01(x - 2, y + 1, rest - 1, a, b);
    int p8 = process01(x - 1, y + 2, rest - 1, a, b);

    // 方法数相加就是我要的最终结果
    return p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8;
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int pick(int dp[10][9][20], int x, int y, int rest);

// 动态规划
int chess02(int a, int b, int k)
{
    // 三维数组,前两维是棋盘大小 10 * 9，第三个是步数大小k
    int dp[10][9][20];
    // 先搞定第一层
    for (int m = 0; m < 20; m++)
    {
        for (int i = 0; i < 10; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                dp[i][j][m] = 0;
            }
        }
    }
    dp[a][b][0] = 1;
    //----------------------------
    for (int rest = 1; rest <= k; rest++)
    {
        for (int x = 0; x < 10; x++)
        { // 0...9
            for (int y = 0; y < 9; y++)
            { // 0...8
                dp[x][y][rest] = pick(dp, x + 1, y + 2, rest - 1);
                dp[x][y][rest] += pick(dp, x + 2, y + 1, rest - 1);
                dp[x][y][rest] += pick(dp, x + 2, y - 1, rest - 1);
                dp[x][y][rest] += pick(dp, x + 1, y - 2, rest - 1);
                dp[x][y][rest] += pick(dp, x - 1, y - 2, rest - 1);
                dp[x][y][rest] += pick(dp, x - 2, y - 1, rest - 1);
                dp[x][y][rest] += pick(dp, x - 2, y + 1, rest - 1);
                dp[x][y][rest] += pick(dp, x - 1, y + 2, rest - 1);
            }
        }
    }
    return dp[0][0][k];
}

// 写一个函数用来判断(x,y)是否越界
int pick(int dp[10][9][20], int x, int y, int rest)
{
    if (x < 0 || x > 9 || y < 0 || y > 8)
    {
        return 0;
    }
    return dp[x][y][rest];
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int main()
{
    cout << chess01(7, 7, 10) << endl;
    cout << chess02(7, 7, 10) << endl;
    return 0;
}