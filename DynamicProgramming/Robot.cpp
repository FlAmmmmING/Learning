// 假设有排成一行的N个位置，记作 1~N , N一定大于或者等于2
// 开始时机器人在其中的M位置上(M一定是1~N中的一个位置)
// 如果机器人来到1的位置，那么下一步只能往右来到2的位置
// 如果机器人来到N的位置，那么下一步只能往左来到N-1的位置
// 如果机器人来到中间位置，那么下一步可以往左走也可以往右走
// 规定机器人必须走K步，最终能来到P位置（P也是1~N中的一个)的方法有多少种？
// 给定四个参数N,M,K,P,返回方法数。


#include <iostream>
using namespace std;
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 初始代码
// 机器人当前的位置是cur
// 机器人还有rest步骤要去走
// 最终目标是aim
// 返回：从cur出发，走了rest步之后，最终停在aim位置的方法数是多少
int robot1(int n, int cur, int rest, int aim)
{
    if (rest == 0)
    {                              // 我已经不需要走了，就返回
        return cur == aim ? 1 : 0; // 如果说cur==aim就说明这是一个方法数，如果不等于就说明这不是一个方法数
    }
    if (cur == 1)
    { // 机器人停留在1位置，下一步一定是迈去2位置
        return robot1(n, 2, rest - 1, aim);
    }
    if (cur == n)
    { // 机器人停留在n位置，下一步一定是迈去n-1位置
        return robot1(n, n - 1, rest - 1, aim);
    }
    // 如果都不是，返回向左边迈去和向右边迈去的方法数之和
    return robot1(n, cur - 1, rest - 1, aim) + robot1(n, cur + 1, rest - 1, aim);
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 动态规划——第一次优化
// 从顶向下的动态规划——记忆化搜索
int process2(int cur, int rest, int aim, int n, int dp[100][100])
{
    if (dp[cur][rest] != -1) // 如果说这个数据不等于-1，就代表了这个状态下我是算过的，那就直接返回就可以了
        return dp[cur][rest];
    // 如果没算过，那就开始算
    int ans = 0;
    if (rest == 0)
        ans = aim == cur ? 1 : 0;
    else if (cur == 1)
        ans = process2(2, rest - 1, aim, n, dp);
    else if (cur == n)
        ans = process2(n - 1, rest - 1, aim, n, dp);
    else
        ans = process2(cur - 1, rest - 1, aim, n, dp) + process2(cur + 1, rest - 1, aim, n, dp);
    // 把ans记录在dp上
    dp[cur][rest] = ans;
    return ans;
}

// cur的范围——1~N
// rest的范围——0~K
int robot2(int N, int start, int K, int aim)
{
    // 首先先创建一个dp数组放下dp[cur][rest]的数据
    int dp[100][100];
    for (int i = 0; i <= N; i++)
    {
        for (int j = 0; j <= K; j++)
        {
            dp[i][j] = -1; // 表示机器人在第i位置，剩下j步的时候，这个状态下我是否有算过，如果没算过，那dp这里就是-1，如果说不等于-1就代表这个返回值放在了这里
        }
    }
    return process2(start, K, aim, N, dp);
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

// 动态规划最终版本
int robot3(int N, int start, int K, int aim)
{
    int dp[100][100];
    // 优先初始化第一列表格的元素
    for (int cur = 0; cur <= K; cur++)
        dp[cur][0] = 0;
    // 当我的rest等于0的时候，只有aim这个格子的值为1.
    dp[aim][0] = 1;

    for (int rest = 1; rest <= K; rest++) // 列
    {
        dp[1][rest] = dp[2][rest - 1];
        for (int cur = 2; cur <= N - 1; cur++)
        {//按照表格当中的顺序去填写即可
            dp[cur][rest] = dp[cur + 1][rest - 1] + dp[cur - 1][rest - 1];
        }
        dp[N][rest] = dp[N - 1][rest - 1];
    }

    // 我最后要的是dp[start][K]的值
    return dp[start][K];
}

//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------

int main()
{
    cout << robot1(4, 2, 4, 4) << endl;
    cout << robot2(5, 2, 6, 4) << endl;
    cout << robot3(5, 2, 6, 4) << endl;
    return 0;
}